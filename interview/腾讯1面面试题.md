1. 为什么打算离开这家公司，是出于什么的考虑呢？

2. 对于新技术的落地，存在的一些风险我们应该怎么去考量？怎么去应对旧技术的迭代？

3. http与https的区别点？

4. http请求中缓存的处理？

5. http请求中get与post的区别？
    get 存在缓存
    post 无法缓存
    get底层实现相对会快很多 - 需要学习

6. 前端攻击时有哪一些手段？
    1. 前端内容注入
    2. 请求拦截注入内容 - https加密数据
    3. dom监听 - 键盘映射、鼠标点击

7. 性能优化有什么方面
    1. 资源加载
    2. 页面渲染
    3. 用户体验

8. 内存泄漏的几种可能？监听/分析内存泄漏的方式？
    1. 内存使用不释放 - 闭包
    2. setInterval 不及时释放
    3. 事件监听不及时remove

9. pm2守护进程 - 是怎么检测各个进程在正常的的运行？ 通过主进程和子进程的进程间通讯


### 笔试题

```javascript

1、给定一个只包含字母与数字随机组合的字符串，要求提取出其中去重后的数字。
例如：const a = 'dw6781b813day7i1p3u21';
输出：678132
const reg = /[^0-9]+/g
const num = Number.parseInt([...new Set(a.replace(reg, '').split(''))].join(''), 10)






2、请使用原生js实时打印<input class=”test”>输入框的值
const input = document.querySelector('.test')
input.addEventListener('nput', function(e) {
console.log(e.target.value)
})



3、已知一异步方法a，调用后延迟300ms返回表示消费金额的数组["6.48"，"8.84"，"23.55"]。要求写一个方法在请求返回后延迟100ms计算总消费金额
function calcTotalAmount() {
const resArr = a() // 异步
setTimeout(() => {
if (!resArr) {
console.log('未拿到数据')
return
}
resArr.reduce((total, cur) => {
total += +cur
return total
}, 0)
}, 400)
}

calcTotalAmount()






4、已知一个存储了100个url的数组[urlA, urlB, urlC .....]，每个url请求后均会返回一个数字。页面每次最多发起10个请求，请实现最短时间内获取所有请求返回的数字之和。
// 发请求  通知我请求到了

const urlArr = [urlA, urlB, ...]
let reqCount = 0
const cache = {}
let count = 0
urlArr.splice(0, 10).forEach(url => {
http(url)
})
const http = function(url) {
return axios.get(url).then((data) => {
cache[url] = data
if (!urlArr.length) {
count = Object.values(cache).reduce((total, cur) => {
total += cur,
return total
}
, 0)
return
}
const url = urlArr.unshift()
http(url)
})
}











5、请简单实现 function A(){} 的单例模式。例如：
const b = new A();
b.say() = 1;
b.learn(3);
b.say() = 3;

const c = new A();
c.say() = 3


const A = (function() {
let instance = null

function _A() {
this.value = 1
}
_A.prototype.say = function() {
return this.value
}
_A.prototype.learn = function(v) {
this.value = v
}
return function A() {
if (!instance) {
instance = new _A(...arguments)
}
return instance
}
})()




6、运⽤你所掌握的数据结构，设计和实现⼀个 LRU (最近最少使⽤) 缓存机制。它应该⽀持以下操作： 获取数据 get 和 写⼊数据 put 。

获取数据 get(key)：如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1

写⼊数据 put(key, value)：如果关键字已经存在，则变更其数据值如果关键字不存在，则插⼊该组「关键字/值」。
当缓存容量达到上限时，它应该在写⼊新数据之前删除最久未使⽤的数据值，从⽽为新的数据值留出空间

例如：
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1); // 返回 1
cache.put(3, 3); // 该操作会使得关键字 2 作废
cache.get(2); // 返回 -1 (未找到)
cache.put(4, 4); // 该操作会使得关键字 1 作废
cache.get(1); // 返回 -1 (未找到)
cache.get(3); // 返回 3
cache.get(4); // 返回 4

// 1. 支持数据读取 2. 支持数据写入

function LRUCache(amount) {
this.amount = amount
this.index = 0
this.map = {} // key - value[value, index ]
this.container = new Array(amount)
}

LRUCache.prototype.put = function(key, value) {
if (this.index > this.amount - 1) {
// 删除最久未使用的数据
}
const exist = this.map[key]
if (!exit) {
this.map[key] = [value, this.index]
this.container[this.index] = value
this.index += 1
} else {
this.container[exist[1]] = value
}
}

LRUCache.prototype.get = function(key) {}












7、（选做题）请实现两存储超出了js内存长度的数字之和


```